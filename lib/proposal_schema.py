"""
Founder-PM Observer Plane â€” Proposal Schema (Phase 3)

Defines the parameter change proposal contract.
Proposals are generated by the Proposal Engine from analysis findings,
and require explicit approval before being applied.

Design:
  - Proposals are mutable (status transitions: pending -> approved/rejected)
  - Each proposal contains a complete diff of parameter changes
  - Version bumping: low impact -> patch, medium/high -> minor
  - One pending proposal at a time (enforced by the engine)
"""

import json
import uuid
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone
from typing import Optional


class ProposalStatus:
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"


class ImpactLevel:
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"


@dataclass
class ParameterDiff:
    """A single parameter change within a proposal."""
    path: str           # dot-notation path e.g. "targets.median_cycle_time_minutes"
    old_value: object   # current value
    new_value: object   # proposed value
    reason: str = ""    # why this change is proposed

    def to_dict(self) -> dict:
        return {
            "path": self.path,
            "old_value": self.old_value,
            "new_value": self.new_value,
            "reason": self.reason,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "ParameterDiff":
        return cls(
            path=data["path"],
            old_value=data["old_value"],
            new_value=data["new_value"],
            reason=data.get("reason", ""),
        )


@dataclass
class Proposal:
    """
    A parameter change proposal generated from analysis findings.

    Lifecycle: pending -> approved | rejected
    """
    proposal_id: str
    created_at: str
    status: str = ProposalStatus.PENDING

    # What triggered this proposal
    findings_summary: list[str] = field(default_factory=list)
    source_report: str = ""  # analysis report filename that triggered this

    # The proposed changes
    parameter_diffs: list[ParameterDiff] = field(default_factory=list)

    # Impact assessment
    impact_level: str = ImpactLevel.LOW
    rationale: str = ""

    # Version management
    version_from: str = ""  # current parameter version e.g. "v0.1.0"
    version_to: str = ""    # proposed new version e.g. "v0.1.1"

    # Approval metadata (populated on approve/reject)
    resolved_by: str = ""
    resolved_at: str = ""
    rejection_reason: str = ""

    def to_dict(self) -> dict:
        d = {
            "proposal_id": self.proposal_id,
            "created_at": self.created_at,
            "status": self.status,
            "findings_summary": self.findings_summary,
            "source_report": self.source_report,
            "parameter_diffs": [diff.to_dict() for diff in self.parameter_diffs],
            "impact_level": self.impact_level,
            "rationale": self.rationale,
            "version_from": self.version_from,
            "version_to": self.version_to,
            "resolved_by": self.resolved_by,
            "resolved_at": self.resolved_at,
            "rejection_reason": self.rejection_reason,
        }
        return d

    def to_json(self, indent: int = 2) -> str:
        return json.dumps(self.to_dict(), indent=indent)

    @classmethod
    def from_dict(cls, data: dict) -> "Proposal":
        diffs = [
            ParameterDiff.from_dict(d)
            for d in data.get("parameter_diffs", [])
        ]
        return cls(
            proposal_id=data["proposal_id"],
            created_at=data["created_at"],
            status=data.get("status", ProposalStatus.PENDING),
            findings_summary=data.get("findings_summary", []),
            source_report=data.get("source_report", ""),
            parameter_diffs=diffs,
            impact_level=data.get("impact_level", ImpactLevel.LOW),
            rationale=data.get("rationale", ""),
            version_from=data.get("version_from", ""),
            version_to=data.get("version_to", ""),
            resolved_by=data.get("resolved_by", ""),
            resolved_at=data.get("resolved_at", ""),
            rejection_reason=data.get("rejection_reason", ""),
        )

    @classmethod
    def from_json(cls, json_str: str) -> "Proposal":
        return cls.from_dict(json.loads(json_str))

    @property
    def is_pending(self) -> bool:
        return self.status == ProposalStatus.PENDING

    @property
    def diff_count(self) -> int:
        return len(self.parameter_diffs)

    @property
    def summary(self) -> str:
        return (
            f"Proposal {self.proposal_id} [{self.status}] "
            f"({self.diff_count} changes, impact={self.impact_level}, "
            f"{self.version_from} -> {self.version_to})"
        )


def generate_proposal_id() -> str:
    """Generate a time-sortable proposal ID."""
    now = datetime.now(timezone.utc)
    date_part = now.strftime("%Y%m%d-%H%M%S")
    unique_part = uuid.uuid4().hex[:6]
    return f"prop-{date_part}-{unique_part}"
